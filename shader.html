<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <title>Living Sand Background</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
        html,
        body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }

        body {
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
        }

        #bg-canvas {
            position: fixed;
            inset: 0;
            width: 100%;
            height: 100%;
            display: block;
            z-index: -1;
            pointer-events: none;
        }

        .page-content {
            position: relative;
            z-index: 1;
            padding: 2rem;
            color: #f5f3ec;
        }
    </style>
</head>

<body>
    <canvas id="bg-canvas"></canvas>

    <div class="page-content">
        <h1>Living sand background</h1>
        <p>Subtle CA-style grains with a natural wind drift.</p>
    </div>

    <script>
        const canvas = document.getElementById('bg-canvas');
        const gl = canvas.getContext('webgl');
        if (!gl) {
            console.error('WebGL not supported');
        }

        // ---------- Resize ----------
        function resize() {
            const dpr = window.devicePixelRatio || 1;
            const w = window.innerWidth;
            const h = window.innerHeight;
            canvas.width = w * dpr;
            canvas.height = h * dpr;
            canvas.style.width = w + 'px';
            canvas.style.height = h + 'px';
            gl.viewport(0, 0, canvas.width, canvas.height);
        }
        window.addEventListener('resize', resize);
        resize();

        // ---------- Utils ----------
        function createShader(type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error(gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }
        function createProgram(vsSource, fsSource) {
            const vs = createShader(gl.VERTEX_SHADER, vsSource);
            const fs = createShader(gl.FRAGMENT_SHADER, fsSource);
            const program = gl.createProgram();
            gl.attachShader(program, vs);
            gl.attachShader(program, fs);
            gl.linkProgram(program);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error(gl.getProgramInfoLog(program));
            }
            return program;
        }
        function createTexture(w, h, data) {
            const tex = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, tex);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, w, h, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
            return tex;
        }
        function createFBO(tex) {
            const fbo = gl.createFramebuffer();
            gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex, 0);
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            return fbo;
        }

        // ---------- Shared vertex shader ----------
        const quadVertSrc = `
attribute vec2 a_position;
varying vec2 v_uv;
void main() {
	v_uv = a_position * 0.5 + 0.5;
	gl_Position = vec4(a_position, 0.0, 1.0);
}
`;

        // ---------- Step shader (CA update pass) ----------
        const stepFragSrc = `
precision mediump float;
varying vec2 v_uv;

uniform sampler2D u_prev;
uniform vec2 u_resolution;
uniform float u_time;

// Small hash
float hash(vec2 p) {
	p = fract(p * vec2(123.34, 345.45));
	p += dot(p, p + 34.345);
	return fract(p.x * p.y);
}

void main() {
	vec2 texel = 1.0 / u_resolution;
	vec2 uv = v_uv;

	float center = texture2D(u_prev, uv).r;
	float up     = texture2D(u_prev, uv + vec2(0.0,  texel.y)).r;
	float down   = texture2D(u_prev, uv + vec2(0.0, -texel.y)).r;
	float left   = texture2D(u_prev, uv + vec2(-texel.x, 0.0)).r;
	float right  = texture2D(u_prev, uv + vec2( texel.x, 0.0)).r;

	// Simple diffusion (like a blur kernel)
	float neighAvg = (up + down + left + right) * 0.25;
	float diffusion = neighAvg - center;

	// Wind direction (tweak for different feel)
	vec2 windDir = normalize(vec2(0.5, 0.2)); // blowing diagonally
	// Sample upwind
	float upwind = texture2D(u_prev, uv - windDir * texel * 1.5).r;
	float wind = upwind - center;

	// Tiny random injection so it never fully freezes
	float rnd = hash(uv * u_resolution + vec2(floor(u_time * 10.0)));

	// Weights
	float diffusionStrength = 0.20; // how much grains spread
	float windStrength      = 0.14; // how much they drift with wind
	float decay             = 0.01; // slow fade
	float noiseStrength     = 0.05; // random specks

	float val = center
		+ diffusion * diffusionStrength
		+ wind * windStrength
		- center * decay
		+ (rnd - 0.5) * noiseStrength;

	// Keep in a nice range
	val = clamp(val, 0.0, 1.0);

	gl_FragColor = vec4(val, val, val, 1.0);
}
`;

        // ---------- Display shader (map sand field to color) ----------
        const displayFragSrc = `
precision mediump float;
varying vec2 v_uv;

uniform sampler2D u_state;
uniform vec2 u_resolution;

// subtle palette + vignette
void main() {
	vec2 uv = v_uv;
	vec2 aspect = vec2(u_resolution.x / u_resolution.y, 1.0);
	vec2 p = (uv - 0.5) * aspect;

	float sand = texture2D(u_state, uv).r;

	// Base "desert gray" tone
	vec3 base = vec3(0.12, 0.11, 0.10);          // dark base
	vec3 sandTint = vec3(0.78, 0.70, 0.58);      // warm sand
	vec3 coolShadow = vec3(0.02, 0.08, 0.10);    // slight cool in shadows

	// Blend sand density into warm tint + shadows
	float shadow = 1.0 - sand;
	vec3 color = base
		+ sand * sandTint * 0.35
		- shadow * coolShadow * 0.20;

	// Vignette for depth
	float r = length(p);
	float vig = smoothstep(0.9, 0.2, r);
	color *= mix(0.85, 1.05, vig);

	color = clamp(color, 0.0, 1.0);
	gl_FragColor = vec4(color, 1.0);
}
`;

        // ---------- Programs ----------
        const stepProgram = createProgram(quadVertSrc, stepFragSrc);
        const displayProgram = createProgram(quadVertSrc, displayFragSrc);

        // Fullscreen quad
        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
            -1, -1,
            1, -1,
            -1, 1,
            -1, 1,
            1, -1,
            1, 1
        ]), gl.STATIC_DRAW);

        // ---------- State textures (ping-pong) ----------
        const stateWidth = canvas.width;
        const stateHeight = canvas.height;

        // Seed with random sand density
        const seedData = new Uint8Array(stateWidth * stateHeight * 4);
        for (let i = 0; i < seedData.length; i += 4) {
            const v = Math.random() * 255;
            seedData[i + 0] = v;
            seedData[i + 1] = v;
            seedData[i + 2] = v;
            seedData[i + 3] = 255;
        }
        const texA = createTexture(stateWidth, stateHeight, seedData);
        const texB = createTexture(stateWidth, stateHeight, seedData);
        let frontTex = texA;
        let backTex = texB;

        const fboA = createFBO(texA);
        const fboB = createFBO(texB);
        let frontFBO = fboA;
        let backFBO = fboB;

        // ---------- Render loop ----------
        let startTime = performance.now();

        function stepCA(time) {
            gl.useProgram(stepProgram);

            const posLoc = gl.getAttribLocation(stepProgram, 'a_position');
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.enableVertexAttribArray(posLoc);
            gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

            const uPrevLoc = gl.getUniformLocation(stepProgram, 'u_prev');
            const uResLoc = gl.getUniformLocation(stepProgram, 'u_resolution');
            const uTimeLoc = gl.getUniformLocation(stepProgram, 'u_time');

            gl.bindFramebuffer(gl.FRAMEBUFFER, backFBO);
            gl.viewport(0, 0, stateWidth, stateHeight);

            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, frontTex);
            gl.uniform1i(uPrevLoc, 0);
            gl.uniform2f(uResLoc, stateWidth, stateHeight);
            gl.uniform1f(uTimeLoc, time);

            gl.drawArrays(gl.TRIANGLES, 0, 6);

            gl.bindFramebuffer(gl.FRAMEBUFFER, null);

            // Swap front/back
            const tmpTex = frontTex; frontTex = backTex; backTex = tmpTex;
            const tmpFbo = frontFBO; frontFBO = backFBO; backFBO = tmpFbo;
        }

        function display(time) {
            gl.useProgram(displayProgram);

            const posLoc = gl.getAttribLocation(displayProgram, 'a_position');
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.enableVertexAttribArray(posLoc);
            gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

            const uStateLoc = gl.getUniformLocation(displayProgram, 'u_state');
            const uResLoc = gl.getUniformLocation(displayProgram, 'u_resolution');

            gl.viewport(0, 0, canvas.width, canvas.height);

            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, frontTex);
            gl.uniform1i(uStateLoc, 0);
            gl.uniform2f(uResLoc, canvas.width, canvas.height);

            gl.drawArrays(gl.TRIANGLES, 0, 6);
        }

        function render() {
            const now = performance.now();
            const t = (now - startTime) / 1000.0;

            // A couple of CA steps per frame keeps it smooth but slow-moving
            stepCA(t);
            stepCA(t + 10.0);

            display(t);
            requestAnimationFrame(render);
        }
        render();
    </script>
</body>

</html>